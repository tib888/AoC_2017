use std::collections::BTreeMap;

fn rotate2(s: &[char; 2 * 2]) -> [char; 2 * 2] {
    [s[2], s[0], s[3], s[1]]
}

fn flip2(s: &[char; 2 * 2]) -> [char; 2 * 2] {
    [s[1], s[0], s[3], s[2]]
}

fn rotate3(s: &[char; 3 * 3]) -> [char; 3 * 3] {
    [s[6], s[3], s[0], s[7], s[4], s[1], s[8], s[5], s[2]]
}

fn flip3(s: &[char; 3 * 3]) -> [char; 3 * 3] {
    [s[2], s[1], s[0], s[5], s[4], s[3], s[8], s[7], s[6]]
}

fn tasks(input: &str, n: i32) -> usize {
    let mut image = vec![
        vec!['.', '#', '.'],
        vec!['.', '.', '#'],
        vec!['#', '#', '#'],
    ];

    let mut rules2 = BTreeMap::<[char; 2 * 2], [char; 3 * 3]>::new();
    let mut rules3 = BTreeMap::<[char; 3 * 3], [char; 4 * 4]>::new();

    for line in input.lines() {
        let mut parts = line.split(" => ");
        let src = parts.next().unwrap();
        let dest = parts.next().unwrap();
        let mut s = src.replace("/", "").chars().collect::<Vec<_>>();
        let mut dv = dest.replace("/", "").chars().collect::<Vec<_>>();

        if s.len() == 2 * 2 {
            let d = [
                dv[0],
                dv[1],
                dv[2],
                dv[3],
                dv[4],
                dv[5],
                dv[6],
                dv[7],
                dv[8],
            ];
            let s0 = [s[0], s[1], s[2], s[3]];
            let sr1 = rotate2(&s0);
            let sr2 = rotate2(&sr1);
            let sr3 = rotate2(&sr2);
            let s0f = flip2(&s0);
            let sr1f = flip2(&sr1);
            let sr2f = flip2(&sr2);
            let sr3f = flip2(&sr3);

            rules2.insert(s0, d);
            rules2.insert(sr1, d);
            rules2.insert(sr2, d);
            rules2.insert(sr3, d);
            rules2.insert(s0f, d);
            rules2.insert(sr1f, d);
            rules2.insert(sr2f, d);
            rules2.insert(sr3f, d);
            continue;
        }
        if s.len() == 3 * 3 {
            let d = [
                dv[0],
                dv[1],
                dv[2],
                dv[3],
                dv[4],
                dv[5],
                dv[6],
                dv[7],
                dv[8],
                dv[9],
                dv[10],
                dv[11],
                dv[12],
                dv[13],
                dv[14],
                dv[15],
            ];
            let s0 = [s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]];
            let sr1 = rotate3(&s0);
            let sr2 = rotate3(&sr1);
            let sr3 = rotate3(&sr2);
            let s0f = flip3(&s0);
            let sr1f = flip3(&sr1);
            let sr2f = flip3(&sr2);
            let sr3f = flip3(&sr3);
            rules3.insert(s0, d);
            rules3.insert(sr1, d);
            rules3.insert(sr2, d);
            rules3.insert(sr3, d);
            rules3.insert(s0f, d);
            rules3.insert(sr1f, d);
            rules3.insert(sr2f, d);
            rules3.insert(sr3f, d);
            continue;
        }

        panic!("0!");
    }

    for _ in 0..n {
        let mut dim = image[0].len();
        if dim % 2 == 0 {
            //println!("{} : 2 / {}", i, dim);
            dim /= 2;
            let mut ni = vec![vec!['.'; dim * 3]; dim * 3];
            for y in 0..dim {
                for x in 0..dim {
                    let key = [
                        image[y * 2 + 0][x * 2 + 0],
                        image[y * 2 + 0][x * 2 + 1],
                        image[y * 2 + 1][x * 2 + 0],
                        image[y * 2 + 1][x * 2 + 1],
                    ];
                    if let Some(pic) = rules2.get(&key) {
                        ni[y * 3 + 0][x * 3 + 0] = pic[0];
                        ni[y * 3 + 0][x * 3 + 1] = pic[1];
                        ni[y * 3 + 0][x * 3 + 2] = pic[2];
                        ni[y * 3 + 1][x * 3 + 0] = pic[3];
                        ni[y * 3 + 1][x * 3 + 1] = pic[4];
                        ni[y * 3 + 1][x * 3 + 2] = pic[5];
                        ni[y * 3 + 2][x * 3 + 0] = pic[6];
                        ni[y * 3 + 2][x * 3 + 1] = pic[7];
                        ni[y * 3 + 2][x * 3 + 2] = pic[8];
                    } else {
                        println!("{:?}", key);
                        panic!("2!");
                    }
                }
            }
            image = ni;
        } else {
            assert!(dim % 3 == 0);
            //println!("{} : 3 / {}", i, dim);
            dim /= 3;
            let mut ni = vec![vec!['.'; dim * 4]; dim * 4];
            for y in 0..dim {
                for x in 0..dim {
                    let key = [
                        image[y * 3 + 0][x * 3 + 0],
                        image[y * 3 + 0][x * 3 + 1],
                        image[y * 3 + 0][x * 3 + 2],
                        image[y * 3 + 1][x * 3 + 0],
                        image[y * 3 + 1][x * 3 + 1],
                        image[y * 3 + 1][x * 3 + 2],
                        image[y * 3 + 2][x * 3 + 0],
                        image[y * 3 + 2][x * 3 + 1],
                        image[y * 3 + 2][x * 3 + 2],
                    ];
                    if let Some(pic) = rules3.get(&key) {
                        ni[y * 4 + 0][x * 4 + 0] = pic[0];
                        ni[y * 4 + 0][x * 4 + 1] = pic[1];
                        ni[y * 4 + 0][x * 4 + 2] = pic[2];
                        ni[y * 4 + 0][x * 4 + 3] = pic[3];
                        ni[y * 4 + 1][x * 4 + 0] = pic[4];
                        ni[y * 4 + 1][x * 4 + 1] = pic[5];
                        ni[y * 4 + 1][x * 4 + 2] = pic[6];
                        ni[y * 4 + 1][x * 4 + 3] = pic[7];
                        ni[y * 4 + 2][x * 4 + 0] = pic[8];
                        ni[y * 4 + 2][x * 4 + 1] = pic[9];
                        ni[y * 4 + 2][x * 4 + 2] = pic[10];
                        ni[y * 4 + 2][x * 4 + 3] = pic[11];
                        ni[y * 4 + 3][x * 4 + 0] = pic[12];
                        ni[y * 4 + 3][x * 4 + 1] = pic[13];
                        ni[y * 4 + 3][x * 4 + 2] = pic[14];
                        ni[y * 4 + 3][x * 4 + 3] = pic[15];
                    } else {
                        println!("{:?}", key);
                        panic!("3!");
                    }
                }
            }
            image = ni;
        }
    }

    //println!("{:?}", image);

    image.iter().fold(0, |acc, x| {
        acc
            + x.iter()
                .fold(0, |acc, x| if *x == '#' { acc + 1 } else { acc })
    })
}

fn main() {
    let d21 = "../.. => ..#/#.#/###
#./.. => .#./#../###
##/.. => #.#/#.#/..#
.#/#. => .##/..#/#..
##/#. => #../#.#/#..
##/## => #.#/.#./#..
.../.../... => ####/##../#.../#...
#../.../... => ##.#/####/.#../....
.#./.../... => ...#/...#/#.../.##.
##./.../... => ###./#.##/#..#/...#
#.#/.../... => ##.#/###./.#.#/##..
###/.../... => .###/#..#/..##/.##.
.#./#../... => ####/#..#/#..#/#..#
##./#../... => #.##/###./##../#...
..#/#../... => ..##/.#.#/..#./.###
#.#/#../... => .##./.#../..#./###.
.##/#../... => ####/..../###./###.
###/#../... => .#.#/.###/##.#/#..#
.../.#./... => ..../.#../.##./..#.
#../.#./... => #.##/..#./####/#.##
.#./.#./... => .#.#/.###/#.#./.#.#
##./.#./... => #..#/#.#./...#/.###
#.#/.#./... => .##./#..#/####/.###
###/.#./... => #.../..../.#.#/##..
.#./##./... => #..#/..##/.##./.#.#
##./##./... => ..##/#..#/####/###.
..#/##./... => ####/.#.#/#.##/#.##
#.#/##./... => .###/...#/#.../...#
.##/##./... => ..##/.#.#/#.../##.#
###/##./... => ##../..#./..#./#...
.../#.#/... => .#.#/##../#..#/.#.#
#../#.#/... => #.##/...#/##../...#
.#./#.#/... => #.../..##/#..#/.##.
##./#.#/... => .##./..##/.#../..#.
#.#/#.#/... => .#../#..#/#.#./....
###/#.#/... => ##.#/..##/##../#...
.../###/... => #.../..#./##../#.##
#../###/... => ..#./#.../##../.##.
.#./###/... => ###./.#.#/..##/##.#
##./###/... => ##.#/#.../##.#/#.#.
#.#/###/... => ..##/...#/##../#..#
###/###/... => ##.#/.###/...#/#..#
..#/.../#.. => .##./#.##/..#./####
#.#/.../#.. => ..#./###./#.../##.#
.##/.../#.. => ...#/...#/.#../.###
###/.../#.. => .##./.#../##../#.#.
.##/#../#.. => ####/..##/#.../##..
###/#../#.. => #.../#..#/####/##..
..#/.#./#.. => .##./##.#/.#../###.
#.#/.#./#.. => ..../.###/###./.#.#
.##/.#./#.. => #.##/#..#/###./..#.
###/.#./#.. => #.../..#./##../.#.#
.##/##./#.. => .##./.#.#/#..#/#..#
###/##./#.. => .#../.#.#/#..#/....
#../..#/#.. => ####/..##/..##/.###
.#./..#/#.. => ###./.###/..#./##.#
##./..#/#.. => .###/####/#.../#.##
#.#/..#/#.. => #.##/#..#/.#.#/...#
.##/..#/#.. => #.../##../..##/##.#
###/..#/#.. => ###./##.#/#.../.#..
#../#.#/#.. => #.#./#.../##../..#.
.#./#.#/#.. => .###/#.#./...#/##.#
##./#.#/#.. => .#../#.##/##.#/#.#.
..#/#.#/#.. => .#../#..#/.#../.#.#
#.#/#.#/#.. => .#../.##./..../..#.
.##/#.#/#.. => .##./.#../####/#.##
###/#.#/#.. => ..#./##../##../#.#.
#../.##/#.. => #.##/.##./..#./..##
.#./.##/#.. => ###./#.#./#.../###.
##./.##/#.. => ####/#.../#.../#.#.
#.#/.##/#.. => .###/#..#/###./#..#
.##/.##/#.. => #.../####/###./###.
###/.##/#.. => .#../.#.#/##../.#..
#../###/#.. => ..#./.##./.###/##..
.#./###/#.. => ####/.##./####/....
##./###/#.. => #.../#.../#.##/.##.
..#/###/#.. => .#.#/.###/...#/....
#.#/###/#.. => ###./..##/.#../#.##
.##/###/#.. => ...#/.#../##../.#..
###/###/#.. => ...#/#.##/.#.#/..##
.#./#.#/.#. => .###/#.../..#./.##.
##./#.#/.#. => ###./##.#/..#./##.#
#.#/#.#/.#. => #.../##.#/..#./#...
###/#.#/.#. => ...#/...#/#..#/...#
.#./###/.#. => #.#./.##./#.#./.###
##./###/.#. => #.../####/..##/#...
#.#/###/.#. => ##../.##./.###/###.
###/###/.#. => ..#./.##./.#../#.#.
#.#/..#/##. => ...#/#.##/##../...#
###/..#/##. => ...#/#.../###./###.
.##/#.#/##. => ##.#/.#.#/.#../....
###/#.#/##. => .##./..../##.#/..#.
#.#/.##/##. => .#../###./#.#./##..
###/.##/##. => #.##/#..#/#.#./###.
.##/###/##. => #.##/###./..../##..
###/###/##. => .#../####/.###/##..
#.#/.../#.# => #.../#..#/..##/##.#
###/.../#.# => #..#/.#.#/####/#.##
###/#../#.# => ###./##../##.#/...#
#.#/.#./#.# => .##./.#.#/#.../...#
###/.#./#.# => .#../.#../..../#.#.
###/##./#.# => #.#./#.#./#.../.#..
#.#/#.#/#.# => ..../####/####/..#.
###/#.#/#.# => #..#/.##./#.../##..
#.#/###/#.# => ###./...#/#.##/##..
###/###/#.# => #.##/#.../#..#/###.
###/#.#/### => ..../...#/###./..#.
###/###/### => #..#/..../#.../#.##";

    println!("{}", tasks(d21, 5));
    println!("{}", tasks(d21, 18));
}
